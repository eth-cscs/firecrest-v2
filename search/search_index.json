{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["trimmer"]},"docs":[{"location":"","title":"FirecREST v2","text":"<p>FirecREST is an open-source, lightweight REST API for accessing HPC resources developed by the Swiss National Supercomputing Centre (CSCS).</p> <p>FirecREST presents a high performance proxy providing a standardized interface to access HPC infrastructures from the web, with authentication and authorization, supporting multiple schedulers, storages, and filesystems types.</p> <p>Using FirecREST, users and web developers can automate access to HPC resources and create client applications, pipelines, and workflow managers on the top of HPC with a standard and secure interface.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83d\udd10 Authentication and authorization layer integrating Open ID Connect (OIDC)/OAuth2 and OpenFGA</li> <li>\u26a1 High-performance RESTful API powered by asyncIO</li> <li>\u2728 Abstracts underlying HPC technology (schedulers, filesystems, storage, etc.) relying in REST API concept and OpenAPI specification</li> <li>\ud83d\udce1 Async SSH connection pool enabling high-throughput regime</li> <li>\ud83e\ude7a Integrated HPC cluster health checker</li> <li>\ud83d\udca0 Modular architecture with a lightweight and modern stack</li> <li>\ud83d\udcbb Easy to integrate with your code using pyFirecREST Python library</li> </ul>"},{"location":"#get-involved","title":"Get involved","text":"<ul> <li> <p>Check out our GitHub repository, clone the repo, try the Demo environment, create issues, contribute, and more!</p> </li> <li> <p>Join the FirecREST Slack community or contact us via email</p> </li> </ul>"},{"location":"#start-using-firecrest","title":"Start using FirecREST","text":"<ul> <li>Follow the Getting Started documentation to quickly start exploring the features of FirecREST first hand</li> <li>Browse the Use Cases, which brings cases of success applying FirecREST on different tools</li> <li>Check out the OpenAPI specification for the complete set of FirecREST endpoints</li> </ul>"},{"location":"getting_started/","title":"Getting started","text":""},{"location":"getting_started/#quick-start","title":"Quick start","text":"<p>The FirecREST demo allows you to run FirecREST on your laptop or workstation and connect to a functional HPC cluster using your personal credentials.</p> <p>Warning</p> <p>This setup is for illustrative and evaluation purposes only and is not intended for production use.</p>"},{"location":"getting_started/#running-the-firecrest-v2-demo-launcher","title":"Running the FirecREST v2 Demo Launcher","text":"<p>Ensure that Docker is installed and running on your machine, then execute the following command to start the FirecREST v2 demo container:</p> <p>Run FirecREST demo launcher</p> <pre><code>$ docker run -p 8025:8025 -p 5025:5025  -p 3000:3000 --pull always ghcr.io/eth-cscs/firecrest-v2-demo:latest\n</code></pre> <p>Once the container is running, open your browser and navigate to:</p> <p>\u27a1\ufe0f http://localhost:8025/</p>"},{"location":"getting_started/#trying-firecrest-in-a-containerised-environment","title":"Trying FirecREST in a containerised environment","text":"<p>In addition, to test and debug FirecREST locally we provide a local Docker environment that already contains all required dependencies (an HPC cluster, identity provider, object storage, etc.). Please make sure Docker is installed and running on your machine.</p> <p>!!!     To start a local Firecrest environment in VSCode right click the selected environment (e.g. <code>docker-compose.yml</code>) and select \"Compose up\"</p> <p>Alternatively, use the command line:</p> <p>Run development environment on CLI</p> <pre><code>$ git clone https://github.com/eth-cscs/firecrest-v2\n$ cd firecrest-v2\n$ docker compose -f docker-compose.yml up\n</code></pre>"},{"location":"getting_started/#local-environment","title":"Local Environment","text":"<p>The environment comes with an OIDC/OAuth2 Identity Provider (Keycloak) for authentication, a dummy HPC cluster (with Slurm as workload manager) and a storage service (MinIO with S3 interface).</p>"},{"location":"getting_started/#users","title":"Users","text":"<p>The environment comes with two predefined users:</p> <ul> <li>fireuser this account represents an actual user</li> <li>firesrv this account represents a service account </li> </ul>"},{"location":"getting_started/#accessing-firecrest","title":"Accessing Firecrest","text":"<ul> <li>The Firecrest endpoints are accessible at: http://localhost:8000/</li> <li>The Firecrest API swagger: http://localhost:8000/docs and http://localhost:8000/redoc</li> </ul> <p>To access most of the end-points you need an authorization token. Firecrest authorization is based on the standard Oauth2 Client Credentials Flow</p> <p>All local environments come with pre-configured test credentials:</p> <p>Firecrest</p> <pre><code>client: firecrest-test-client\nsecret: wZVHVIEd9dkJDh9hMKc6DTvkqXxnDttk\n</code></pre> <p>To obtain an access token you can either use the Authorize button in the swagger documentation or directly access Keycloak's OAuth2 token end-point:</p> <p>Note</p> <p>We use for these examples curl and jq commands</p> Obtain access token <pre><code>$ CLIENT_ID=\"firecrest-test-client\"\n$ CLIENT_SECRET=\"wZVHVIEd9dkJDh9hMKc6DTvkqXxnDttk\"\n$ access_token$(curl -s -X POST http://localhost:8080/auth/realms/kcrealm/protocol/openid-connect/token \\\n-d \"grant_type=client_credentials\" -d \"client_id=$CLIENT_ID\" -d \"client_secret=$CLIENT_SECRET\" \\\n-H \"Content-Type: application/x-www-form-urlencoded\" -H \"Accept: */*\" | jq --raw-output .\"access_token\")\n$ echo $access_token\neyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJ1Xz.......\n</code></pre>"},{"location":"getting_started/#api-call-examples","title":"API call examples","text":"<p>Note</p> <p>In this dev environment there are 2 clusters for testing: <code>cluster-slurm-ssh</code> and <code>cluster-slurm-api</code>. We will use the first one in this example</p> List <code>$HOME</code> directory content <pre><code>    $ curl -s \"http://localhost:8000/filesystems/cluster-slurm-ssh/ops/ls?path=/home/fireuser\" \\\n    -H \"Authorization: Bearer $access_token\" | jq .\n    {\n        \"output\": [\n            {\n                \"name\": \"tmp\",\n                \"type\": \"d\",\n                \"linkTarget\": null,\n                \"user\": \"fireuser\",\n                \"group\": \"users\",\n                \"permissions\": \"rwxr-xr-x\",\n                \"lastModified\": \"2025-03-18T11:01:43\",\n                \"size\": \"4096\"\n            }\n        ]\n    }\n</code></pre> Submit a job to the workload manager and scheduler <pre><code>curl -X POST -s \"http://localhost:8000/compute/cluster-slurm-ssh/jobs\" \\\n    --json '{\"job\": {\"script\": \"#!/bin/bash -l\\nfor i in {1..100}\\ndo\\necho $i\\nsleep 1\\ndone\", \"working_directory\": \"/home/fireuser\"}}'  \\\n    -H \"Authorization: Bearer $access_token\" -H \"Content-Type: application/json\" | jq .\n{\n    \"jobId\": 5\n}\n</code></pre> Check status of the job <pre><code>curl -X GET -s \"http://localhost:8000/compute/cluster-slurm-ssh/jobs/5\" -H \"Authorization: Bearer $access_token\" -H \"Content-Type: application/json\" | jq .\n{\n    \"jobs\": [\n        {\n        \"jobId\": 5,\n        \"name\": \"Count\",\n        \"status\": {\n            \"state\": \"COMPLETED\",\n            \"stateReason\": \"None\",\n            \"exitCode\": 0,\n            \"interruptSignal\": 0\n        },\n        \"tasks\": [\n            {\n            \"id\": \"5.batch\",\n            \"name\": \"batch\",\n            \"status\": {\n                \"state\": \"COMPLETED\",\n                \"stateReason\": null,\n                \"exitCode\": 0,\n                \"interruptSignal\": 0\n            },\n            \"time\": {\n                \"elapsed\": 101,\n                \"start\": 1742492131,\n                \"end\": 1742492232,\n                \"suspended\": 0,\n                \"limit\": null\n            }\n            }\n        ],\n        \"time\": {\n            \"elapsed\": 101,\n            \"start\": 1742492131,\n            \"end\": 1742492232,\n            \"suspended\": 0,\n            \"limit\": 7200\n        },\n        \"account\": \"staff\",\n        \"allocationNodes\": 1,\n        \"cluster\": \"cluster\",\n        \"group\": \"users\",\n        \"nodes\": \"localhost\",\n        \"partition\": \"part01\",\n        \"priority\": 1,\n        \"killRequestUser\": null,\n        \"user\": \"fireuser\",\n        \"workingDirectory\": \"/home/fireuser\"\n        }\n    ]\n}\n</code></pre>"},{"location":"setup/arch/","title":"Architecture of FirecREST","text":"<p>FirecREST is presented as a simple interface to access HPC resources with an HTTP enabled API. </p> <p>In this chapter it is shown how FirecREST is configured from the architectural point of view to provide this integration with HPC clusters, workload manager and schedulers, authentication, data transfer, etc.</p>"},{"location":"setup/arch/#the-full-picture","title":"The full picture","text":"<p>In the figure below it can be seen the different components of the ecosystem of FirecREST. The API doesn't provide these components, instead, it uses known standards in the industry while providing abstractions to support multiple techonologies.</p> <p></p> <p>The dashed lines represents components that are optional, while the solid lines are mandatory for a proper use of FirecREST.</p>"},{"location":"setup/arch/#1-hpc-systems-and-workload-manager-and-schedulers","title":"(1) HPC Systems and workload manager and schedulers","text":"<p>Check out here how does FirecREST connect to the systems to execute commands and interact with the scheduler and filesystems.</p>"},{"location":"setup/arch/#2-authenticationauthorization","title":"(2) Authentication/Authorization","text":"<p>Review how FirecREST enables access and fine-grained permissions here.</p>"},{"location":"setup/arch/#3-data-transfers","title":"(3) Data Transfers","text":"<p>FirecREST handles data transfer up to 5 TB. See how this is done here.</p>"},{"location":"setup/arch/#4-health-checks","title":"(4) Health checks","text":""},{"location":"setup/arch/auth/","title":"Authentication and Authorization on FirecREST","text":"<p>FirecREST relies on industry standards for authentication (AuthN) and authorization (AuthZ), providing easy integration third party auth solutions.</p> <p>Note</p> <p>You can refer to this document to better understand the difference between AuthN and AuthZ.</p>"},{"location":"setup/arch/auth/#authentication","title":"Authentication","text":"<p>FirecREST enables OpenID Connect (OIDC) and OAuth 2.0 as the standard for authentication layer.</p> <p>A JSON Web Tokens (JWT) is sent within the <code>Authorization</code> header bearer token with information related to the user that executes a command on the HPC system.</p> <p>This JWT (also known as \"access token\") works as a credential to access the API instead of using username/password or SSH credentials.</p> <p>This means that the HPC center using FirecREST must be supplied with an Identity Provider (IdP) that supports OIDC/OAuth2 Bearer Tokens for proper use of the API.</p> <p>As IdPs that supports OIDC/OAuth2 we can find Keycloak, ShibbolethIDP5, Auth0, WSO2 Identity Server, among others.</p> <p>Note</p> <p>Note that in order to provide HPC user information in the IdP, this must be somehow synchronized with the user database of the HPC center (ie, LDAP). For instance, in ShibbolethIDP5 it is mandatory to provide a functional LDAP server to start the IdP service.</p>"},{"location":"setup/arch/auth/#token-validation","title":"Token validation","text":"<p>The public key of the IdP must be set on FirecREST configuration to decode the JWT and check the access token has not expired and has been issued by a trusted IdP. This offline validation of the access token can also be complemented by evaluating specific scopes and roles in the token.</p> <p>Note</p> <p>Access token format depends on how the IdP is configured to issue access tokens. FirecREST allows different settings to decrypt and decode the JWT.</p> <p></p> <p>Given that FirecREST solely requires a valid access token from a trusted IdP, therefore the client application consuming FirecREST can use any authorization grant defined in the OAuth2 protocol</p> <ul> <li>Authorization code: used in UI applications (browser, mobile, etc).</li> <li>Implicit</li> <li>Password credentials, and</li> <li>Client credentials</li> </ul> <p>Client credential type is especially important for APIs such as FirecREST, since it enables automated pipelines and workflows on HPC (for instance, a CI/CD pipeline that test a scientific library performs as expected on the HPC system every day at the same time, or automaticaly triggered after a maintainence, etc).</p> <p>You can see a list of use cases where client credentials grant type is crucial to perform the workflow here.</p>"},{"location":"setup/arch/auth/#a-note-on-client-credentials-grant-type","title":"A note on Client Credentials grant type","text":"<p>As mentioned above, client credentials grant type is an important case of authentication method for FirecREST, since it enables machine-to-machine communication, without the need of on-site human intervention with the AuthN process, enabling automated pipelines and cron jobs to run on HPC.</p> <p>A limitation with client credentials is that it's not designed to be used by \"human\" clients but for machines (also known as \"service accounts\" for some IdPs), and thus it doesn't include any information of the user.</p> <p>This integration between users and clients must be done on the HPC center side. FirecREST expects that the access token's <code>preferred_username</code> or <code>username</code> claims are populated with the user name on the target system (see FirecREST command execution docs)</p>"},{"location":"setup/arch/auth/#authorization","title":"Authorization","text":"<p>Note</p> <p>The authorization layer is optional on FirecREST. By default no extra authorization more than validating the access token is done.</p> <p>FirecREST supports fine-grained authorization allowing the community to easily integrate different paradigms within the API.</p> <p>Typical use cases for having an AuthZ layer for HPC access are listed below:</p> <ul> <li> <p>Limit users to access HPC cluster/resources: users can be allowed via LDAP/SSH to use the cluster, however since the API is a different type of access you could limit how the users interface resources with a programmatic layer.</p> </li> <li> <p>Constraint users (or OIDC clients) to access endpoints of the API: a user would like to set its client only for job submissions, another for data transfer, another for both, etc.</p> </li> <li> <p>Quota management: limit the usage of resources (workload schedulers and managers, storage, etc) using FirecREST.</p> </li> </ul>"},{"location":"setup/arch/auth/#firecrest-rebac-authz","title":"FirecREST ReBAC AuthZ","text":"<p>By default, it provides native integration with OpenFGA an open-source tool that uses Relationship Based Access Control (ReBAC) paradigm as authorization solution.</p> <p>The OpenFGA adapter presented on the FirecREST-v2 package works as a client for the AuthZ service, expecting the latter to allow authentication with the same IdP.</p> <p></p> <p>Note</p> <p>FirecREST is flexible enough to allow the community to create adapters that support different approaches and technologies for AuthZ like ReBAC, ABAC, RBAC, etc. We encourage the deployers and users to create pull requests on this repository to extend the usage of the API.</p>"},{"location":"setup/arch/systems/","title":"FirecREST command execution","text":""},{"location":"setup/arch/systems/#the-simplistic-approach","title":"The simplistic approach","text":"<p>The goal of FirecREST is to provide an HTTP interface to HPC, this means that the interface FirecREST presents to the users and applications must handle HTTP requests with according parameters, verbs, etc.</p> <p>FirecREST receives these requests and translates them into HPC logic, and after the operations are done (ie, commands executed, data uploaded, etc) it returns an HTTP response that complies with the protocol used.</p> <p></p>"},{"location":"setup/arch/systems/#going-deeper","title":"Going deeper","text":"<p>The command execution from FirecREST API server to the HPC cluster is done via SSH connection using HPC system users' credentials.</p> <p>This means that FirecREST can be installed in any platform or infrastructure (cloud provider, VM, local system) with SSH access to the target system(s) configured. It doesn't need to be installed in the same VPN or VLAN of the system.</p> <p>Info</p> <p>FirecREST doesn't execute commands as <code>root</code> user or using <code>sudo</code> commands. All commands are executed on behalf of the users using the users' credential.</p>"},{"location":"setup/arch/systems/#jwt-to-ssh-delegation","title":"JWT to SSH Delegation","text":"<p>To answer to the question on \"how the SSH credentials are obtained or created\", FirecREST provides an integration with JSON Web Tokens used to authenticate agains the API.</p> <p>FirecREST uses the <code>username</code> or <code>preferred_username</code> claim from the JWT access token created by the Identity Provider (IdP) when the user or application authenticated to use the API.</p> <p>Info</p> <p>This <code>username</code> value on the token must be a valid username on the HPC system, otherwise the SSH credential created on its behalf won't be allowed in the system.</p> <p>The JWT signature is verified using the Identity Provider (IdP) public key, and then the token time validity is checked. If both are successful, the <code>username</code> is extracted and a SSH key is created for the user if there isn't an active connection to the cluster.</p>"},{"location":"setup/arch/systems/#obtaining-ssh-credentials-on-behalf-of-the-user","title":"Obtaining SSH credentials on behalf of the user","text":"<p>FirecREST provides an abstraction to allow different ways of getting SSH credentials for the user. Currently, there are the 2 options available:</p> <p></p> <ol> <li> <p>Using an \"SSH Service\"</p> <p>If the HPC center has an API or web service that translates a JWT into an SSH credential, you can connect FirecREST to this service.</p> <p></p> <p>In this case, the user sends the JWT to FirecREST and it is forwarded to the SSH Service. Therefore, the IdP that generates JWT must be trusted by both FirecREST and the SSH Service.</p> <p>Once the SSH credential is created, FirecREST uses the SSH credential to execute commands.</p> <p>The benefit of this approach is that SSH credentials creation and validation is managed within the specific groups.</p> </li> <li> <p>Using static SSH credentials</p> <p>Additionally, FirecREST provides a way to map user identities in the JWT with SSH credentials by using the firecrest-config.yaml.</p> <p></p> <p>SSH credentials or the users should be managed as secrets and should be updated by the administrator of the FirecREST deployment if they change.</p> </li> </ol>"},{"location":"setup/arch/systems/#ssh-configuration-in-target-systems","title":"SSH Configuration in target systems","text":"<p>Info</p> <p>All these configurations are optional, but strongly suggested to increase security (remember that we are allowing machines to machine communication via SSH, we don't want an SSH DoS!) and provide high througput regime via API</p> <p>It is recommended to set a specific <code>Match</code> section on the Open SSHD configuration for requests from FirecREST:</p> <p>Login node SSHd Config</p> <pre><code>$ cat /etc/ssh/sshd_config\n(...)\n# To accept FirecREST host\nMatch Address {IP_ADDR_or_RANGE}\n    TrustedUserCAKeys /path/to/ssh/key.pub\n    PermitRootLogin no\n    DenyGroups root bin admin sys\n    MaxAuthTries 1\n    AllowTcpForwarding no\n    MaxSessions 2500\n</code></pre>"},{"location":"setup/arch/systems/#ssh-configuration-details","title":"SSH Configuration details","text":"<p>Note</p> <p>You can follow this link to have a more complete understanding on SSH configuration used below</p> <ul> <li> <p><code>Match Address</code>: points the IP address (or range) from where FirecREST server connects to the cluster. This way, this <code>Match</code> block only process SSH connections from FirecREST.</p> </li> <li> <p><code>TrustedUserCAKeys</code>: in case of using an SSH Service this option points to the path where the public key of the Certificate Authority that signs SSH credentials is stored.</p> </li> <li> <p><code>DenyGroups</code>: to avoid these special permission groups from executing commands via FirecREST</p> </li> <li> <p><code>MaxSessions</code>: sessions are a result of (SSH connections x Commands executed). The default value is <code>10</code>, but to allow high throughput regime on commands execution via FirecREST, set this value to a higher number (recommended <code>9999</code> which is the max allowed value).</p> </li> </ul> <p></p>"},{"location":"setup/arch/systems/#how-to-enable-high-throughput-regime-via-firecrest","title":"How to enable High Throughput Regime via FirecREST","text":"<p>To enable high throughput operations on HPC via an API, the FirecREST team has set the SSH connection pool.</p> <p>Instead of using one SSH connection+channel per command, this approach re-uses an SSH connection to execute several commands on a row.\u200b</p> <p>Each connection in the pool is closed after a time of inactivity, leaving it available for the next user.</p> <p></p> <p>Note</p> <p>Using this setup, stress testing has proven that 500 clients can produce ~195 request per second with a latency of 900 ms, and an error rate of 0.04%\u200b (always depending of the infrastructure, filesystems, network latency, etc)</p>"},{"location":"setup/conf/","title":"FirecREST-v2 Configuration","text":"<p>How to edit the <code>firecrest-config.yaml</code> file</p> <ul> <li>Systems (clusters) and schedulers</li> <li>Authentication/Authorization</li> <li>Service account and health checks</li> <li>Storage</li> </ul>"},{"location":"setup/deploy/","title":"FirecREST-v2 Deployment","text":""},{"location":"setup/deploy/#helm-charts","title":"Helm Charts","text":"<p>This repository includes a Helm chart to deploy FirecREST version 2.</p>"},{"location":"setup/deploy/#fetching-the-repository","title":"Fetching the repository","text":"<pre><code>helm repo add firecrest-v2 https://eth-cscs.github.io/firecrest-v2/charts/\nhelm repo update\n</code></pre> <p>The available versions can be listed with <pre><code>helm search repo firecrest-v2/firecrest-api --versions\n</code></pre></p> <p>Deploying the chart <pre><code>helm install --create-namespace &lt;deployment-name&gt; -n &lt;namespace&gt; firecrest-v2/firecrest-api --values values.yaml\n</code></pre></p>"},{"location":"use_cases/","title":"FirecREST use cases","text":"<ul> <li>CI/CD pipeline</li> <li>Workflow orchestrators</li> <li>JupyterHub</li> <li>More...</li> </ul>"},{"location":"user_guide/","title":"User Guide","text":""},{"location":"user_guide/#authentication","title":"Authentication","text":"<p>FirecREST authentication follows the OpenID Connect (OIDC) standard.</p> <p>To access most endpoints (see the API reference), you must provide a JWT authorization token in the <code>Authorization</code> header:</p> <p>Authorization header</p> <pre><code>Authorization: Bearer &lt;token&gt;\n</code></pre> <p>FirecREST authenticates users by verifying the JWT token\u2019s signature against trusted certificates (see the configuration section). If the JWT token is valid, FirecREST extracts the <code>username</code> or <code>preferred_username</code> claim to establish the user's identity and propagate it downstream (e.g., for SSH authentication).</p> <p>To obtain a JWT token, you need a trusted Identity Provider that supports OAuth2 or OpenID Connect protocols. The FirecREST Docker Compose development environment (see the Getting Started section) includes a preconfigured Keycloak identity provider.</p> <p>There are multiple grant flows available to obtain a JWT token. The most common ones are:</p>"},{"location":"user_guide/#client-credentials-grant","title":"Client Credentials Grant","text":"<p>This grant is used to authenticate an application (client) rather than an individual user. However, since HPC infrastructures typically require usage tracking, it is recommended to create a dedicated client for each user or project and assign a service account owned by the user/project to the client. </p> <p>Important: Using the identity provider to associate a user or project with a client offers a secure and flexible way to map HPC internal users to FirecREST credentials: client credential \u2190 service account \u2190 user/project</p> <p>In this flow, the client submits its <code>client_id</code> and <code>client_secret</code> directly to the authorization server to obtain an access token and a refresh token.</p> <p>Obtain an access token</p> <pre><code>curl --request POST \\\n--url 'http://localhost:8080/auth/realms/kcrealm/protocol/openid-connect/token' \\\n--header 'content-type: application/x-www-form-urlencoded' \\\n--data grant_type=client_credentials \\\n--data client_id=firecrest-test-client \\\n--data client_secret=wZVHVIEd9dkJDh9hMKc6DTvkqXxnDttk\n</code></pre> <p>Note: The above <code>curl</code> command is configured to work with the provided Docker Compose environment. </p> <p>Expected output example</p> <pre><code>{\"access_token\":\"&lt;token&gt;\",\"expires_in\":300,\"token_type\":\"Bearer\",\"scope\":\"firecrest-v2 profile email\"} \n</code></pre>"},{"location":"user_guide/#authorization-code-grant","title":"Authorization Code Grant","text":"<p>This grant is intended for web applications. The user's browser is redirected (HTTP 302) to the authorization server, which handles authentication (e.g., via username/password, two-factor authentication, etc.).</p> <p>After successful authentication, the authorization server redirects the browser back to a pre-registered endpoint in the web application, passing an authorization code. The web application then uses its own credentials (<code>client_id</code> and <code>client_secret</code>) along with the authorization code to request an access token from the authorization server.</p>"},{"location":"user_guide/#api-reference","title":"API Reference","text":""},{"location":"user_guide/#accessing-http-restful-resources","title":"Accessing HTTP RESTful Resources","text":"<p>The FirecREST API follows RESTful design principles, allowing access to the underlying resources through standard HTTP requests.</p> <p>Each request consists of:</p> <ul> <li>Endpoint (URL): The address of the resource being accessed.</li> <li>Method: One of <code>GET</code>, <code>POST</code>, <code>PUT</code>, or <code>DELETE</code>, depending on the action.</li> <li>Headers: Metadata necessary for authorisation.</li> <li>Body: The request payload in JSON format.</li> </ul> <p>Below is a quick overview of the methods:</p> Method Description <code>GET</code> Retrieves resources <code>POST</code> Creates resources <code>PUT</code> Updates resources <code>DELETE</code> Deletes resources <p>The request body format is specific to each call, the full list of available API calls and requests can be found here: API reference.</p>"},{"location":"user_guide/#response-structure","title":"Response Structure","text":"<p>Each FirecREST API response consists of:</p> <ul> <li>Status Code: Indicates the outcome of the request.</li> <li>Headers: Metadata related to the response.</li> <li>Body: The response data in JSON format.</li> </ul> <p>Below is an overview of HTTP status codes and their meanings:</p> Code Category Description 1xx Informational Communicates protocol-level information 2xx Success Indicates the request was successfully processed 3xx Redirection Instructs the client to take additional action 4xx Client Error Indicates an issue with the request sent by the client 5xx Server Error Indicates an issue on the server's side"},{"location":"user_guide/#resource-groups","title":"Resource Groups","text":"<p>FirecREST API endpoints are categorized into three groups:</p> Group URL Prefix Description Status <code>/status/...</code> Provides status information about FirecREST and underlying resources Compute <code>/compute/...</code> Grants access to the job scheduler Filesystem <code>/filesystem/...</code> Provides access to the filesystem"},{"location":"user_guide/#targeting-systems","title":"Targeting Systems","text":"<p>A single FirecREST instance can manage multiple HPC systems. Most endpoints require specifying which system to access by including the system name in the endpoint path.</p> <p>For example:</p> <p>Endpoint path</p> <pre><code>/compute/{system_name}/jobs\n</code></pre> <p>The <code>{system_name}</code> should correspond to the cluster name provided in the FirecREST configuration.  Refer to the configuration section for details.</p>"},{"location":"user_guide/#full-api-endpoints-list","title":"Full API Endpoints List","text":"<p>The complete list of FirecREST API endpoints is available here:  API reference</p>"},{"location":"user_guide/#synchronous-and-asynchronous-calls","title":"Synchronous and Asynchronous Calls","text":"<p>Most FirecREST endpoints operate synchronously, meaning that the invoked operation is completed before a response is provided. All synchronous responses have a fixed timeout of 5 seconds. If the operation cannot be completed within this time limit, an error is returned.</p> <p>A limited set of filesystem-specific operations are executed asynchronously. These calls are non-blocking, and a jobId is returned. It is the user\u2019s responsibility to track the status of the remote job and retrieve the result upon completion.</p> <p>All asynchronous endpoints are located under  <code>/transfer</code> and follow this path structure:</p> <p>Asynchronous transfers endpoint</p> <pre><code>/filesystem/{system_name}/transfer/...\n</code></pre>"},{"location":"user_guide/#file-transfer","title":"File transfer","text":"<p>FirecREST provides two methods for transferring files: - Small files (up to 5MB by default) can be uploaded or downloaded directly. - Large files must first be transferred to a staging storage system (e.g., S3) before being moved to their final location on the HPC filesystem.</p> <p>Small file transfer endpoints:  - <code>/filesystem/{system_name}/ops/download</code>  - <code>/filesystem/{system_name}/ops/upload</code></p> <p>Large file transfer endpoints:  - <code>/filesystem/{system_name}/transfer/download</code>  - <code>/filesystem/{system_name}/transfer/upload</code></p>"},{"location":"user_guide/#downloading-large-files","title":"Downloading Large Files","text":"<p>When requesting a large file download, FirecREST returns a download URL and a jobId. Once the remote job is completed, the user can retrieve the file using the provided URL.</p>"},{"location":"user_guide/#uploading-large-files","title":"Uploading Large Files","text":"<p>For large file uploads, FirecREST provides multi part upload URLs, the number of URLs depends on the file size. The user must split the file accordingly and upload each part to the assigned URL.</p> <p>Once all parts have been uploaded, the user must call the provided complete upload URL to finalize the transfer. After completion, a remote job moves the file from the staging storage to its final destination.</p>"},{"location":"user_guide/#multi-part-upload-example","title":"Multi part upload example","text":"<p>Split your large file into as many parts as provided partsUploadUrls by the <code>/filesystem/{system}/transfer/upload</code> end-point:</p> <p>Split large file to upload</p> <pre><code>$ split -n 7 -d large-file.zip large-file-part-\n</code></pre> <p>Upload each individual part following the correct part order:</p> <p>Upload parts call</p> <pre><code>$ curl 'https://rgw.cscs.ch/firecresttds%3Auser/62ad2cd8-7398-4955-929d-cbfae5088c6a/large-file.zip?uploadId=2~qiT12y-T1Hhl_ELCozIt3ZlLhMoTcmy&amp;partNumber=1&amp;X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=GET9Y98HGJARIS4I447Z%2F20250325%2Fcscs-zonegroup%2Fs3%2Faws4_request&amp;X-Amz-Date=20250325T071416Z&amp;X-Amz-Expires=604800&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Signature=d0edacd3fe1d3dc1e38f5d632f7760275cda29e9e41c49548b5da94e47699400' --upload-file large-file-part-00\n</code></pre> <p>Complete the upload by calling the completeUploadUrl:</p> <p>Complete upload call</p> <pre><code>$ curl 'https://rgw.cscs.ch/firecresttds%3Auser/62ad2cd8-7398-4955-929d-cbfae5088c6a/large-file.zip?uploadId=2~qiT12y-T1Hhl_ELCozIt3ZlLhMoTcmy&amp;X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=GET9Y98HGJARIS4I447Z%2F20250325%2Fcscs-zonegroup%2Fs3%2Faws4_request&amp;X-Amz-Date=20250325T071416Z&amp;X-Amz-Expires=604800&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Signature=d0edacd3fe1d3dc1e38f5d632f7760275cda29e9e41c49548b5da94e47699400'\n</code></pre>"},{"location":"user_guide/#firecrest-sdk","title":"FirecREST SDK","text":"<p>PyFirecREST is a Python library designed to simplify the implementation of FirecREST clients.</p>"},{"location":"user_guide/#installation","title":"Installation","text":"<p>To install PyFirecREST, run:</p> <p>Install <code>pyfirecrest</code></p> <pre><code>$ python3 -m pip install pyfirecrest\n</code></pre> <p>For more details, visit the official documentation page.</p>"},{"location":"user_guide/#list-files-example","title":"List files example","text":"<p>List files with <code>pyfirecrest</code></p> <pre><code>import firecrest as fc\n\nclass MyAuthorizationClass:\n    def get_access_token(self):\n        return &lt;TOKEN&gt;\n\nclient = fc.v2.Firecrest(firecrest_url=&lt;firecrest_url&gt;, authorization=MyAuthorizationClass())\n\nfiles = client.list_files(\"cluster\", \"/home/test_user\")\nprint(files)\n</code></pre> <p>More examples are available at: pyfirecrest.readthedocs.io</p>"}]}